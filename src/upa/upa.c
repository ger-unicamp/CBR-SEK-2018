#pragma config(Sensor, S1,     cor,            sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S2,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S3,     ultra,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          garra,         tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          dir,           tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          esq,           tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DIST_BONECO	25
#define DIST_ANDAR 15
#define TAM 6
#define POTENCIA 20
#define FRENTE 1
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0

//Ultrassonico
bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 5;

	//Leitura do Vetor
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ultra);
	}

	//Ordenacao do Vetor
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}

		k--;
	}

	//Retorna a Mediana do Vetor
	if (vet[5] < DIST_BONECO){
		return true; //Boneco Encontrado
		}else{
		return false; //Boneco Nao Encontrado
	}
}

void AndarReto (int sentido){
	setMotorSync(dir,esq,-0.5,sentido*POTENCIA);
}

void GirarRobo(int degree, int sentido){
	delay(1000);
	resetGyro(gyro);
	delay(1000);
	//Sets the sound volume of the EV3 speaker to 75
	setSoundVolume(75);

	// Starts playing a soundfile, 'Bravo.rsf' on the EV3
	playSoundFile("Bravo");

	// Gives the file 2 seconds to play
	sleep(2000);

	repeatUntil(abs(getGyroDegrees(gyro)) > degree){

		if(sentido == ANTIHORARIO){
			//Point turn to the left
			setMotorSpeed(esq, -5);
			setMotorSpeed(dir, 5);
			}else{
			//Point turn to the right
			setMotorSpeed(esq, 5);
			setMotorSpeed(dir, -5);
		}
	}
	setMotorSpeed(esq, 0);
	setMotorSpeed(dir, 0);
	delay(1000);
	resetGyro(gyro);
	delay(1000);

	if(sentido == FRENTE){
		AndarReto(FRENTE);
	}


	//Stop the motors at the end of the turn
	setMotorSpeed(esq, 0);
	setMotorSpeed(dir, 0);
	delay(1000);

}

void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 10);
	moveMotorTarget(esq, angulo, 10);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao para pegar boneco
** Param:
*/
void pega_boneco(){
	anda_x_cm (7.5);
	AndarReto(0);
	GirarRobo(88,HORARIO); //giro (direita)
	setMotorTarget (garra, 300, 10);
	waitUntilMotorStop (garra);
	anda_x_cm (DIST_ANDAR);
	waitUntilMotorStop (garra);
	setMotorTarget (garra, 70, 10);
	waitUntilMotorStop (garra);
	anda_x_cm (-DIST_ANDAR);
	GirarRobo(88,ANTIHORARIO);//giro (esquerda);
}

task main()
{
	bool ult;

	while(true){
		ult = ultrassonico();
		if(ult){
			pega_boneco();
		}else{
			AndarReto(1);
	}
	}
}
