#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Gyro)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 01/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 25 / 30
#define FRENTE 1
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
int bonecos_total = 0;

/*Informacoes*/
typedef struct dados{
	TLegoColors cor;
	int dir;
	int bonecos_total; // numero de bonecos total na pista
	int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
	int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita
}dados;

/*Pilha*/
typedef struct Pilha{
	int max;
	int topo;
	dados elems[TAM];
}Pilha;

/*Funcao para inicializar pilha
** Param: tamanho do vetor
*
Pilha *iniciar_pilha(int TAM){
int i;
Pilha* retorno;//Ponteiro para Pilha
retorno->max = tamanho_vetor;
retorno->topo = 0;
for(i=0;i<TAM;i++){
retorno->elems[i].cor = 0;
retorno->elems[i].dir = 0;
}
return retorno;
}*/

/*Funcao verificar pilha vazia
** Param: ponteiro para pilha
*
bool empty(Pilha *p){
if(p->topo == 0){ //Pilha Vazia
return true;
}else{
return false;
}
}*/

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha *p, TLegoColors cor, int dir){
	if(p->topo == p->max){ //Pilha cheia
		displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
		}else{
		p->elems[p->topo].cor = cor;
		p->elems[p->topo++].dir = dir;
		return true;
	}
}

/*Funcao troca sentido
** Param: ponteiro para pilha
*/
void troca(Pilha *p){
	int i;

	for(i=0;i<p->topo;i++){
		if(p->elems[i].dir == FRENTE){
			p->elems[i].dir = TRAS;
			}else if(p->elems[i].dir == ANTIHORARIO){
			p->elems[i].dir = HORARIO;
			}else if(p->elems[i].dir == HORARIO){
			p->elems[i].dir = ANTIHORARIO;
		}
	}

}

/*Funcao imprime
** Param: ponteiro para pilha
*
void imprime_pilha(Pilha *p){
int i;
displayBigTextLine(line1,"Imprimir Pilha:\n");
for(i=0;i<p->topo;i++){
displayBigTextLine(line1,"cor:%d",p->elems[i].cor);
displayBigTextLine(line2,"dir:%d",p->elems[i].dir);
}
}*/

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao para girar robo
** Param: sentido do giro
*/
void GirarRobo(int degree, int sentido){
	//Keep looping until the gyro sensor reads greater
	//than 90 degrees (from latest reset position)
	repeatUntil(getGyroHeading(S4) > degree){

		if(sentido == ANTIHORARIO){
			//Point turn to the left
			setMotorSpeed(esq, -50);
			setMotorSpeed(dir, 50);
			}else{
			//Point turn to the right
			setMotorSpeed(esq, 50);
			setMotorSpeed(dir, -50);
		}
	}

	if(sentido == FRENTE){
		AndarReto(FRENTE);
	}


	//Stop the motors at the end of the turn
	setMotorSpeed(esq, 0);
	setMotorSpeed(dir, 0);
	delay(100);
	resetGyro(S4);
}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor){
	bool getColor = false;
	TLegoColors color;

	while(!getColor){
		color = getColorName(sensor);
		if(color != colorNone)
			getColor = true;
		else
			getColor = false;
	}

	return color;
}

/* Função para saber se existe boneco a ser recolhido ou não
** Params: nenhum
*/
bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
		vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	//Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
		return true;
		}else{
		return false;
	}
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha *p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p->elems[i].cor == cor){
			displayBigTextLine(line1,"ndeu certo");
			return true;
		}
	}
	return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor
*/
bool checa_dir(Pilha *p, int dir, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p->elems[i].dir == dir){
			if(p->elems[i].cor == cor){
				displayBigTextLine(line1,"ndeu certo"); //Cor e direcao salvo
				return true;
				}else{
				return false;
			}
		}
	}
	return false;
}

/*Retorna na ultima interseccao
** Param:
*/
void volta(bool plaza){
	int andar = 1;
	while(andar){
		AndarReto(TRAS);
		if(getColor(S2) != colorWhite && ultrassonico() == false && plaza == false){ // Verifica se esta em uma interseccao - verificar cor
			andar = 0;
		}
	}
}

/*Funcao que verificar qual direcao seguir, caso errada, volta para ultiam interseccao
** Param: Ponteiro para pilha, direcao, cor
*/
bool testa_dir(Pilha *p, int direcao, TLegoColors cor, bool plaza){
	int andar = 1;

	GirarRobo(90,direcao); //Vira o robo para direcao dada

	while(andar){
		AndarReto(FRENTE); // Andar reto
		if(ultrassonico() == true){ //procura boneco enquanto testa
			bonecos_total++;
			p->elems[p->topo].bonecos_bifurcacao++;
			p->elems[p->topo].bonecos_direita++;
		}

		if(cor != colorWhite && cor != colorBlack){ // Verifica se esta em outra interseccao
			AndarReto(DESLIGA);
			return true;
			}else if(cor == colorBlack){ // Verifica se esta em rua sem saida - chao preto
			AndarReto(DESLIGA);
			volta(plaza); // Funcao que faz o robô voltar até a ultima interseccao
			return false;
		}
	}
	return false;
}

/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void run_rua(Pilha *p, TLegoColors cor, bool plaza){
	int i;

	if(ultrassonico() == true){ //Verifica de tem boneco
		bonecos_total++; //contar todos os bonecos
		p->elems[p->topo].bonecos_bifurcacao++; //contar bonecos na bifurcacao
		p->elems[p->topo].bonecos_direita++; //contar numero de bonecos a direita em uma bifurcacao
	}

	if(cor != colorWhite && !checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		if(!checa_dir(p,ANTIHORARIO,cor) && testa_dir(p,ANTIHORARIO,cor,plaza)){ //verifica se a direcao esta na pilha - ESQUERDA
			push(p,cor,ANTIHORARIO); //testa
			}else if(!checa_dir(p,HORARIO,cor) &&  testa_dir(p,HORARIO,cor,plaza)){
			push(p,cor,FRENTE); //testa
			}else{
			testa_dir(p,HORARIO,cor,plaza);
			push(p,cor,HORARIO);
		}
		}else{
		for(i=0;i<=TAM;i++){ //
			if(cor == p->elems[i].cor){
				GirarRobo(90,p->elems[i].dir);
			}
		}
	}
}

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
	float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
		} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao para pegar boneco
** Param:
*/
void pega_boneco(){

	GirarRobo(90,HORARIO); //giro (direita)
	setMotorTarget (cancela, 140, 10);
	waitUntilMotorStop (cancela);
	anda_x_cm (DIST_ANDAR);
	setMotorTarget (cancela, 0, 5);
	waitUntilMotorStop (cancela);
	anda_x_cm (DIST_ANDAR);
	GirarRobo(90,ANTIHORARIO);//giro (esquerda);
}

/*Funcao estado plaza
** Param: cor
*/
void estado_plaza (){
	while (getColor(S2) != colorBlack){//Anda para frente com uma distância de no mínimo 50cm e máximo de 100cm de distância da parede.
		if (getUSDistance(ult) >100){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
			}else if (getUSDistance(ult) < 50) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
			}else{
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
		}
	}

	//Depositar bonecos
	if(getColor(S2) == colorBlack){	//Anda 30cm, abre a cancela anda 50cm para trás, fecha a cancela e gira 180°
		anda_x_cm (30);
		setMotorTarget (cancela, 120, 10); //Abre cancela
		waitUntilMotorStop (cancela);
		anda_x_cm (-50);
		setMotorTarget (cancela, 0, 10); //Fecha cancela
		waitUntilMotorStop (cancela);
		GirarRobo(180,ANTIHORARIO); //Gira 180°
		sleep (1570);
		setMotorSpeed(dir, 0);
		setMotorSpeed(esq,0);
		anda_x_cm (30);
	}

	while (getColor(S2) != colorBlack){//Volta para a rampa, tentando manter a distância minima de 50cm e máxima de 100cm da parede
		if (getUSDistance(ult) > 100){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
			}else if (getUSDistance(ult) < 50) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
			}else{
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
		}
	}
}

/* Função Principal */
task main(){

	/* declaração de variáveis*/
	Pilha *p;
	int i;
	bool ult, plaza = false;
	TLegoColors cor;
	int estado = RETO;

	/* inicialização necessárias */
	p->max = TAM;
	p->topo = 0;
	for(i=0;i<TAM;i++){
		p->elems[i].cor = colorBrown; /*testar inicialziar*/
		p->elems[i].dir = 0;
	}

	/* loop infinito*/
	while (true){
		ult = ultrassonico();
		cor = getColor(S2);

		if(cor == colorWhite){
			if(!ult){
				if(!plaza){
					estado = RETO;
					}else{
					estado = PLAZA;
				}
			}
			else
				estado = CAPTURAR;
			}else{
			// descobrir se eh rampa na ida ou interseccao
			if(cor == colorRed){
				// robô vai poucos cm a frente e faz nova leitura da cor
				setMotorSpeed(dir, 5);
				setMotorSpeed(esq, 5);
				delay(800);
				cor = getColor(S2);
				if(cor == colorBlue){
					estado = RAMPA_IDA;
					}else{
					estado = INTERSECCAO;
				}
				}else{
				// descobrir se eh rampa na volta ou interseccao
				if(cor == colorGreen){
					setMotorSpeed(dir, 5);
					setMotorSpeed(esq, 5);
					delay(800);
					cor = getColor(S2);
					if(cor == colorBlue){
						estado = RAMPA_VOLTA;
						}else{
						estado = INTERSECCAO;
					}
				}
			}
		}

		switch(estado){
		case RETO:
			AndarReto(FRENTE);
			break;
		case CAPTURAR:
			pega_boneco();
			break;
		case INTERSECCAO:
			run_rua(p,cor,plaza);
			break;
		case RAMPA_IDA:
			// sobe a rampa
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
			// após subir a rampa, robo estará no plaza
			plaza = true;
			break;
		case PLAZA:
			estado_plaza ();
			break;
		case RAMPA_VOLTA:
			// desce a rampa
			setMotorSpeed(dir, 20);
			setMotorSpeed(esq, 20);
			// após descer a rampa, robo estará no labirinto
			plaza = false;
			//CHAMAR FUNÇÃO PARA INVERTER AS DIREÇÕES DAS INTERSECCOES NA PILHA
			troca(p);
			break;
		default:
			break;
		}
	}
}
