//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma config(Sensor, S1,     ultranxt,       sensorSONAR)
#pragma config(Sensor, S2,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     ultraev3,       sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     otherultraev3,  sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)

/*
**
** Codigo principal do robo da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassonico e de cor
** GER - Grupo de Estudos em Robótica
** 20/03/2018 - Atualizado em 2018
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA		    4
#define PLAZA			5
#define SEM_SAIDA		6

/* Outras definicoes */
#define DIST_BONECO		25
#define DIST_ANDAR 11.3
#define TAM 4
#define POTENCIA 20 

/* Definicoes de direcoes das interseccoes */
#define DIREITA 1
#define FRENTE 2
#define ESQUERDA 3

/* Definicoes para motores */
#define TRAS -1
#define DESLIGA 0
#define POTENCIA_GIRO 10

/* Definicoes de calibracao */
#define CALIBRA_GIRO 3.1
#define CALIBRA_RETO 21.7

/* Estrutura para armazenar infos do labirinto */
typedef struct dados{
	TLegoColors cor;
	int dir;
}dados;

int topo, interseccoes = 0;
float DIST_PISO = 0;

/* Pilha para estrategia do labirinto */
typedef struct Pilha{
	int max;
	dados elems[TAM];
}Pilha;

/* Variaveis globais */
int sem_saida = 0;
int estado = RETO;
bool plaza = false, volta = false;

/* Funcao para andar x cm atraves de calibracao de parametros
** Param: distancia x
** Retorna: void
*/
void anda_x_cm (float x){
	float encoder;
	int sinal;

	encoder = (x*CALIBRA_RETO);

	if (encoder >= 0){
		sinal = 1;
		} else {
		sinal = -1;
	}

	setMotorSyncEncoder(dir, esq, 0, encoder, -sinal*POTENCIA);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);
}

/* Funcao que insere elemento na pilha
** Param: ponteiro para pilha, direcao e cor
** Retorna: booleano para sucesso ou nao ao inserir dado
*/
bool push (Pilha *p, TLegoColors cor, int dir){
	if(topo == p->max){ //Pilha cheia
		//displayBigTextLine(line6,"Erro: stack overflow\n");
		return false;
	}else{
		p->elems[topo].cor = cor;
		p->elems[topo++].dir = dir;
		return true;
	}
}

/* Funcao que imprime dados da piolha
** Param: ponteiro para pilha
*/
/*
void imprime_pilha(Pilha p){
	int i;
	displayBigTextLine(line1,"Imprimir Pilha:\n");
	for(i=0;i<topo;i++){
		displayBigTextLine(line1,"cor:%d",p.elems[i].cor);
		displayBigTextLine(line2,"dir:%d",p.elems[i].dir);
	}
}*/

/*Funcao para andar reto usando metodos nativos do ev3
** Param: sentido frente ou atrás
** Retorna: void
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0.75,-sentido*POTENCIA);
}


/*Funcao para girar robo
** Param: angulo (em graus), sentido (DIREITA ou ESQUERDA)
** Retorna: void
*/
void GirarRobo (float angulo, int sentido){
	float encoder;

	encoder = (angulo*CALIBRA_GIRO);

	//GIRAR DIREITA
	if(sentido == DIREITA){
		encoder = encoder;
		setMotorSyncEncoder(dir,esq,100,encoder,-30);

		waitUntilMotorStop(dir);
		waitUntilMotorStop(esq);

		}else{
		if(sentido == ESQUERDA){
			encoder = encoder;
			setMotorSyncEncoder(dir,esq,-100,encoder,-30);

			waitUntilMotorStop(dir);
			waitUntilMotorStop(esq);

		}
	}
}

/* Funcao do estado captura bonecos
** Params: null
** Retorna: void
*/
void pega_boneco(){
	anda_x_cm (15.25); 					// teste para deixar o boneco no centro
	GirarRobo(90,ESQUERDA); 			// giro (direita)
	setMotorTarget (cancela, 120, 10);
	waitUntilMotorStop (cancela);
	anda_x_cm (DIST_ANDAR);
	setMotorTarget (cancela, 25, 100);
	waitUntilMotorStop (cancela);
	setMotorTarget (cancela, 0, 100);
	anda_x_cm (-DIST_ANDAR);
	GirarRobo(90,DIREITA);				//giro (esquerda);
}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
** Retorna: cor lida pelo sensor
*/
TLegoColors getColor(tSensors sensor){
	long int redValue;
	long int greenValue;
	long int blueValue;

	// Pega os valores de verde, vermelho e azul e grava nas respectivas variaveis
	getColorRGB(sensor, redValue, greenValue, blueValue);
	// valores rgb são calibrados para que o metodo funcione corretamente
	// se alguma COR for detectada
	if((redValue >= 5) || (greenValue >= 5) || (blueValue >= 5)){
		// BRANCO
		if(redValue >= 60 && greenValue >= 60 && blueValue >= 35){
			return colorWhite;
			}else{
			// VERDE
			if((redValue <= 12) && (greenValue >= 15) && (blueValue <= 13)){
				return colorGreen;
				}else{
				// VERMELHO MALDITO
				if((redValue >= 40) && (greenValue <= 10) && (blueValue <= 10)){
					return colorRed;
					}else{
					// AMARELO
					if((redValue >= 50) && (greenValue >= 20) && (blueValue <= 10)){
						return colorYellow;
						}else{
						// AZUL
						if((redValue <= 15) && (greenValue >= 25) && (blueValue >= 25)){
							return colorBlue;
							}else{

							// PRETO
							if((redValue <= 10) && (greenValue <= 10) && (blueValue <= 10)){
								return colorBlack;
							}
						}
					}
				}
			}
		}
	}
	// nenhuma cor lida
	return colorNone;
}

/*
** Funcao para uso do sensor ultrassonico
** Params: sensor usado (do ev3 ou nxt, nesse caso)
** Retorna: booleano 
*/
bool ultrassonico(tSensors sensor){
	float vet[11];
	int i;
	int j;
	float aux;
	int k = 10;

	// caso a leitura seja do sensor do nxt (para detectar bonecos)
	if(sensor == ultranxt){
		for (i=0; i<11; i++){
			vet[i] = SensorValue[ultranxt];
		}

		// Bubble Sort
		for(i = 0; i < 11; i++){
			for(j = 0; j < k; j++){
				if(vet[j] > vet[j+1]){
					aux = vet[j];
					vet[j] = vet[j+1];
					vet[j+1]=aux;
				}
			}
			k--;
		}

		// Ver se o sensor achou o boneco e retorna true ou false
		if (vet[5] < DIST_BONECO){
			return true;
			}else{
			return false;
		}
	}
	else{
		// se for para ler sensor do ev3
		if(sensor == ultraev3 || sensor == otherultraev3){
			for (i=0; i<11; i++){
				vet[i] = getUSDistance(sensor);
			}
			// Bubble Sort
			for(i = 0; i < 11; i++){
				for(j = 0; j < k; j++){
					if(vet[j] > vet[j+1]){
						aux = vet[j];
						vet[j] = vet[j+1];
						vet[j+1]=aux;
					}
				}
				k--;
			}
			if((vet[5] >= DIST_PISO+1)){
				return true;
			}
			else
				return false;
		}
	}
	return false;
}

/* Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
** Retorna: booleano se cor ja estiver na pilha
*/
bool checa_cor(Pilha p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].cor == cor){
			return true;
		}
	}
	return false;
}

/* Funcao para manobrar o robo
** Essa funcao foi usada emergencialmente na competicao devido a
** problemas do robo tender a sair da pista (para a direita)
** Params: null
** Retorna: void
*/
void manobra(){
	AndarReto(DESLIGA);

	// corrige robo indo para esquerda
	while(ultrassonico(ultraev3)){
		GirarRobo(10,ESQUERDA);
	}
	delay(500);

}


/* Funcao para manobrar o robo
** Essa funcao foi usada emergencialmente na competicao 
** Params: null
** Retorna: void
*/
void manobraleft(){
	AndarReto(DESLIGA);
	while(ultrassonico(otherultraev3)){
		GirarRobo(10,DIREITA);
	}
	delay(500);

}

/* Funcao para subir rampa
** Params: null
** Retorna: void
*/
void rampa(){
	bool ultev3, otherultev3;
	while (getUSDistance(ultranxt) > 100){
		ultev3 = ultrassonico(ultraev3);
		otherultev3 = ultrassonico(otherultraev3);

		if(!ultev3 && !otherultev3){
			AndarReto(1);
		} else if (ultev3 && !otherultev3){
			manobra();
		} else if(!ultev3 && otherultev3){
			manobraleft();
		} else{
			while(ultev3 && otherultev3){
				GirarRobo(5,ESQUERDA);
			}
		}
	}
}

/* Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor
** Retorna: booleano se direcao esta na pilha
*/
/*
bool checa_dir(Pilha p, int dir, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		if(p.elems[i].dir == dir){
			if(p.elems[i].cor == cor){
				return true;
			}else{
				return false;
			}	
		}
	}
	return false;
}*/

/* Funcao troca sentido das direcoes da pilha
** Param: ponteiro para pilha
** Retorna: void
*/
void troca(Pilha *p){
	int i;

	for(i=0; i<topo; i++){
		if(p->elems[i].dir == ESQUERDA){
			p->elems[i].dir = DIREITA;
		} else if(p->elems[i].dir == DIREITA){
			p->elems[i].dir = ESQUERDA;
		}
	}
}

/*
** Funcao para mudar direcao da cor na pilha
** Deve ser usada na volta do plaza para direcoes gravadas na pilha
** ja que o robo inverte seu sentido
** Params: pilha e cor lida pelo sensor
** Retorna: booleano se operacao funcionar
*/
bool increment_dir(Pilha *p, TLegoColors cor){
	int i;
	for(i=0;i<TAM;i++){
		// verifica se cor ja esta na pilha para inverter direcao
		if(cor == p->elems[i].cor){
			p->elems[i].dir++;
			return true;
		}
	}
	return false;
}

/* Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
** Retorna: void
*/
void interseccao(Pilha p, TLegoColors cor){
	int i;
	int direcao;

	if(!checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
		// coloca na pilha
		push(p,cor,DIREITA);
		playSound(soundLowBuzzShort);
		//	setLEDColor(ledGreenFlash);
		//displayBigTextLine(line2,"PUSH NA PILHA");
		// primeira tentativa sempre vai para a direita
		GirarRobo(90, DIREITA);
		anda_x_cm(15);
		// indica que passou por uma interseccao
		if(volta == false){
			interseccoes++;
		}
		else{
			interseccoes--;
		}
	}
	else{
		if(sem_saida == 1){
			setLEDColor(ledRedPulse);
			playSound(soundFastUpwardTones);
			GirarRobo(90,DIREITA);
			//untilDifferentColor();
			anda_x_cm(15);
			// muda direcao anterior na pilha, pois robo encontrou rua sem saida
			increment_dir(p, cor);
			sem_saida = 0;
		}
		else{
			for(i=0;i<TAM;i++){
				// se tiver cor na pilha
				if(cor == p.elems[i].cor){
					//displayBigTextLine(line4,"temos cor");
					direcao = p.elems[i].dir;
					// passou pela primeira vez por outra interseccao
					interseccoes++;

					// vira de acordo com a direcao na pilha
					if(direcao == DIREITA)
					{
						GirarRobo(90, DIREITA);
					}
					else{
						if(direcao == ESQUERDA)
						{
							GirarRobo(90, ESQUERDA);
						}
					}
					setLEDColor(ledOrangeFlash);
					//untilDifferentColor();
					anda_x_cm(15);
				}
			}
		}
	}
	estado = RETO;
}

/*
** Funcao do Estado Plaza
** Algoritmo:
** 1.Andar reto mantendo 77,5 cm* de distância entre as paredes enquanto cor (branco)
** 2.Quando cor for preto, usando os dados do encoder dos motores, andar por mais 30 cm (centro do círculo preto).
** 3.Para e levanta a cancela para depositar os bonecos.
** 4.Anda para trás por uma distância suficiente para sair do círculo preto e gira 180°.
** 5.Andar reto mantendo 77,5 cm de distância entre as paredes.
** 6.Ao dectetar faixas de cores mudar de estado
** comprimento do módulo: 185 cm
** largura do robô: 30 cm
** 185-30 = 155 / 2 = 77,5
** Param: null
** Retorna: void
*/
void estado_plaza (){

	float sensor_esq;
	float sensor_dir;
	float diferenca;

	while (getColor(color) != colorBlack){			//Anda para frente com uma distância de no mínimo 50cm e máximo de 100cm de distância da parede.
		if (getUSDistance(ultranxt) > 85){
			setMotorSpeed(dir, 18);
			setMotorSpeed(esq, 22);
			} else if (getUSDistance(ultranxt) < 65) {
			setMotorSpeed(dir, 22);
			setMotorSpeed(esq, 18);
			} else {
			AndarReto (1);
		}
	}
	//Anda pra frente, abre a cancela anda para trás, fecha a cancela e gira 180°
	anda_x_cm (15);
	setMotorTarget (cancela, 120, 30);
	waitUntilMotorStop (cancela);
	anda_x_cm (-60);
	setMotorTarget (cancela, 0, 10);
	waitUntilMotorStop (cancela);
	delay(1000);
	sensor_esq = getUSDistance(S1);
	GirarRobo(180,DIREITA);
	delay(1000);
	sensor_dir = getUSDistance(S1);
	diferenca = (sensor_esq - sensor_dir);

	// atraves do ultrassonico ajusta o robo para sair corretamente do plaza
	while (diferenca > 1 || diferenca < -1){
		if (diferenca > 1){
			GirarRobo(90, DIREITA);
			delay(100);
			anda_x_cm(1);
			delay(100);
			GirarRobo(90, DIREITA);
			delay(1000);
			sensor_esq = getUSDistance(S1);
			GirarRobo(180,ESQUERDA);
			delay(1000);
			sensor_dir = getUSDistance(S1);
			diferenca = (sensor_esq - sensor_dir);
			} else {
			GirarRobo(90, ESQUERDA);
			delay(100);
			anda_x_cm(1.5);
			delay(100);
			GirarRobo(90, ESQUERDA);
			delay(1000);
			sensor_esq = getUSDistance(S3);
			GirarRobo(180,ESQUERDA);
			delay(1000);
			sensor_dir = getUSDistance(S3);
			diferenca = (sensor_esq - sensor_dir);
		}
	}

	anda_x_cm(50);
	setMotorSpeed(dir,0);
	setMotorSpeed(esq,0);
}

/* Funcao para o estado sem saida
** Param: null
** Retorna: void
*/
void semSaida(){
	playSound(soundLowBuzz);
	// gira o robo
	GirarRobo(180, ESQUERDA);
	sem_saida = 1;
	//anda_x_cm(10);
	estado = RETO;
}

/*
** Task principal
*/
task main(){
	playSound(soundException);

	Pilha p;
	int i, nBonecos = 0;
	float aux = 0;
	bool ultev3, ultnxt, otherultev3;
	TLegoColors cor, cor_aux;

	// calibra a distancia do robo da superficie de contato
	float vet[11];

	/* inicialização necessárias */
	p.max = TAM;
	topo = 0;
	for(i=0;i<TAM;i++){
		p.elems[i].cor = colorBrown; /*testar inicializar*/
		p.elems[i].dir = 0;
	}

	// le as distancias do ultrassonico para calibrar
	for(i=0; i < 10; i++){
		aux = getUSDistance(ultraev3);
		vet[i] = aux;
	}

	int j,k = 10;
	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
				aux = vet[j];
				vet[j] = vet[j+1];
				vet[j+1]=aux;
			}
		}
		k--;
	}

	// Pega mediana das medidas da alturas como parametro
	DIST_PISO = vet[5];

	// Entra em loop infinito 
	while(true){
		setLEDColor(ledRedPulse);	// acende led vermelho apenas para debug
		cor = getColor(S2);			

		if(cor != colorNone){
			if(cor == colorBlack){		// se for cor preta, le cor de novo para evitar erros do sensor 
				AndarReto(DESLIGA);
				delay(1000);
				cor = getColor(S2);
				// se a cor for preta é sem saida
				if(cor == colorBlack && plaza == false){
					AndarReto(TRAS);
					delay(1300);
					AndarReto(DESLIGA);
					estado = SEM_SAIDA;
					playSoundFile("Dog whine");	// apenas para debug
				}
			}
			else{
				// le a distancia da superficie para saber se robo esta saindo do caminho
				ultev3 = ultrassonico(ultraev3);
				otherultev3 = ultrassonico(otherultraev3);

				if(!ultev3 && !otherultev3){
					// se robo nao estiver saindo da rota, ve se eh interseccao
					if(cor == colorYellow || cor == colorGreen || cor == colorRed){
						AndarReto(DESLIGA);
						delay(500);
						cor_aux = getColor(S2);
						if(cor_aux == colorRed){
							// apos quatro interseccoes é certeza que a prox cor vermelha sera rampa
							if(interseccoes == 4){
								if(volta == false){
									estado = RAMPA;
								}
							}
							else{
								anda_x_cm(18);
								estado = INTERSECCAO;
							}
						}
						else{
							if(cor_aux == cor){
								//displayText(line1,"estado interseccao")
								anda_x_cm(18);
								estado = INTERSECCAO;
							}
						}
					}
					else{
						if(cor == colorWhite){
							if(plaza == false){
								estado = RETO;
								if(nBonecos == 0){
									// veja se ha bonecos nos postos ao lado do robo
									ultnxt = ultrassonico(ultranxt);
									if(ultnxt){
										estado = CAPTURAR;
									}
								}
							}
							else{
								// se passou pela rampa, o estado sera plaza
								estado = PLAZA;
							}
						}
					}
				}
				else{
					// se robo estiver torto, saindo da rua, corrige a direcao com ultrassonico a direita
					if(ultev3){
						manobra();
					}else if(otherultev3){
						manobraleft();
					}

				}
			}
		}

		// inicio da maquina de estados
		switch(estado){
			case INTERSECCAO:
				interseccao(p,cor);
				if(interseccoes == 0 && volta == true){
					GirarRobo(180, ESQUERDA);
					troca(&p);
					volta = false;
					interseccoes++;
				}
				break;
			case RETO:
				AndarReto(1);
				break;
			case SEM_SAIDA:
				semSaida();
				break;
			case CAPTURAR:
				AndarReto(DESLIGA);
				pega_boneco();
				nBonecos++;
				AndarReto(DESLIGA);
				// se estiver contrario ao plaza
				if(volta == true){
					//gira o robo 180º
					GirarRobo(180, ESQUERDA);
					troca(&p);
					volta = false;
				}
				estado = RETO;
				break;
			case RAMPA:
				// sobe a rampa
				rampa();
				plaza = true;
				break;
			case PLAZA:
				interseccoes = 0;
				// deixa bonecos no plaza
				estado_plaza();
				// troca direcoes na pilha
				troca(&p);
				plaza = false;
				// sai do plaza, volta para as ruas
				volta = true;
				nBonecos = 0;
				break;
		}
	}
}