#pragma config(Sensor, S1,     ultra,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     sensor_cor,     sensorNone)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#define frente 1
#define tras -1

//Vetor
typedef struct dados{
    int cor;
    int dir;
}dados;

//Pilha
typedef struct Pilha{
    int max;
    int topo;
    dados elems[tam];
}Pilha;


//Inicializar Pilha
Pilha* iniciar_pilha(int tamanho_vetor){
int i;

    Pilha* retorno;//Ponteiro para Pilha
    retorno->max = tamanho_vetor;
    retorno->topo = 0;
    for(i=0;i<tamanho_vetor;i++){
    	retorno->elems[i].cor = 0;
    	retorno->elems[i].dir = 0;
  	}
   return retorno;

}


//Verificar Pilha Vazia
bool empty(Pilha *p){

    if(p->topo == 0){ //Pilha Vazia
        return true;
    }else{
        return false;
    }
}


//Remover
bool pop (Pilha *p){
    if(empty(p) == true){
        displayBigTextLine(line1,"Erro: pilha vazia\n");
        return false;
    }else{
        p->elems[--p->topo];
        return true;
    }
}


//Inserir
bool push (Pilha *p, int cor, int dir){
    if(p->topo == p->max){ //Pilha cheia
        displayBigTextLine(line6,"Erro: stack overflow\n");
        return false;
    }else{
        p->elems[p->topo].cor = cor;
        p->elems[p->topo++].dir = dir;
        return true;
    }
}


//Imprime
void imprime_pilha(Pilha *p){
int i;

    displayBigTextLine(line1,"Imprimir Pilha:\n");

    for(i=0;i<p->topo;i++){
        displayBigTextLine(line1,"cor:%d",p->elems[i].cor);
        displayBigTextLine(line2,"dir:%d",p->elems[i].dir);
    }
}


//Ultrassonico
bool ultrassonico(){
int vet[11];
int i;
int j;
int aux;
int k = 10 ;

    //Leitura do Vetor
    for (i=0; i<11; i++){
        vet[i] = getUSDistance(ultra);
    }

    //Ordenacao do Vetor
    for(i = 0; i < 11; i++){
        for(j = 0; j < k; j++){
            if(vet[j] > vet[j+1]){
                aux = vet[j];
                vet[j] = vet[j+1];
                vet[j+1]=aux;
            }
        }

        k--;
    }

    //Retorna a Mediana do Vetor
    if (vet[5] < DIST_BONECO){
        return true; //Boneco Encontrado
    }else{
        return false; //Boneco Nao Encontrado
    }
}

void andar (int p){
	setMotorSyncEncoder(dir,esq,p*-3.5,1000,p*50);
}

void gira_robo(int graus){
		setMotorTarget (dir, graus, 20);//gira 180º
		setMotorTarget (esq, -graus, 20);
		waitUntilMotorStop(esq);
		waitUntilMotorStop(dir);
}



bool procura_boneco(){
	int achou = 0;
	//colocar logica de achar boneco
	if(achou){
		return false;
	}
	else return true;
}

bool checa_cor(Pilha *p, int cor){
    int i;
    for(i=0;i<tam;i++){
        if(p->elems[i].cor == cor){
                //printf("\ndeu certo\n");
            return true;
        }
    }
    return false;
}

bool checa_dir(Pilha *p, int dir){
    int i;
    for(i=0;i<tam;i++){
        if(p->elems[i].dir == dir){
                //printf("\ndeu certo\n");
            return true;
        }
    }
    return false;
}

//Retorna à última intersecção
void voltar(Pilha *p){
    int andar = 1;
    while(andar){
        andar(tras);
        if(intersecção()){ // Verifica se está em itnersecção
            andar = !andar;
        }
    }
}

//Chuta uma direção e vai nela, se não for a certa volta pra última intersecção
bool testa_dir(Pilha *p, int dir){
    int andar = 1;

    gira_robo(dir); //Vira o robô para a direção dada // Implementada só definir quantos graus cada dir

    while(andar){
        andar(frente); // Anda reto //Função implementada já
        if(intersecção()){ // Verifica se está em outra intersecção
            andar = !andar;
            return true;
        }else if(rua_semsaida()){ // Verifica se esta em rua sem saida
            andar = !andar;
            voltar(); // Função que faz o robô voltar até a última intersecção
            return false;
        }
    }
}

void run_intersecao(){ //Roda quando intersecao() for true
	if(procura_boneco()){
		boneco++;
	}
	if(cor != 0 && !checa_cor()){ //se cor for diferente de branco e nao estiver na pilha...
		if(checa_dir(*p,2)){ //verifica se a direcao esta na pilha
			testa_dir(*p,2); //testa fren
		}
		else if(checa_dir(*p,0)){
			testa_dir(*p,0); //testa frente
		}
		else testa_dir(*p,1); //testa direita
	}
	else if (checa_cor(*p,cor)){

		for(i=0;i<=max;i++){ //
			if(cor == elems[i].cor){
				push(*p,cor,elems[i].dir)
				i = max;
			}
		}
	}
	else{
		estado++;
		break;
	}

}

int estado = 0;

task main()
{
	switch(estado){
			case 0:
			run_intersecao();
			case 1:
			set_motor_sleep()//Algo do tipo que faz o robo parar, só para nao bugar o programa no estado++ da linha 204
}
