#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Gyro)
#pragma config(Motor,  motorA,          dir,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          esq,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          cancela,       tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
**
** Código principal do robô da categoria IEEE SEK 2017
** Baseado em uma máquina de estados dependente de sensores ultrassônico e de cor
** GER - Grupo de Estudos em Robótica
** 01/11/2017
**
*/

/* Definição de estados */
#define RETO 			1
#define INTERSECCAO		2
#define CAPTURAR		3
#define RAMPA_IDA		4
#define PLAZA			5
#define RAMPA_VOLTA		6

/* Outras definições */
#define DIST_BONECO		25
#define DIST_ANDAR 30
#define TAM 6
#define POTENCIA 25 / 30
#define FRENTE 1
#define TRAS -1
#define ANTIHORARIO -1 //ESQUERDA
#define HORARIO 1 //DIREITA
#define DESLIGA 0
int bonecos_total = 0;

/*Informacoes*/
typedef struct dados{
    TLegoColors cor;
    int dir;
    int bonecos_total; // numero de bonecos total na pista
    int bonecos_bifurcacao; //total de bonecos presentes na bifurcacao (esquerda + direita)
    int bonecos_direita; //bonecos esquerda = bonecos_bifurcacao - bonecos_direita
}dados;

/*Pilha*/
typedef struct Pilha{
    int max;
    int topo;
    dados elems[TAM];
}Pilha;

/*Funcao para inicializar pilha
** Param: tamanho do vetor
*
Pilha *iniciar_pilha(int TAM){
int i;
Pilha* retorno;//Ponteiro para Pilha
    retorno->max = tamanho_vetor;
    retorno->topo = 0;
    for(i=0;i<TAM;i++){
        retorno->elems[i].cor = 0;
        retorno->elems[i].dir = 0;
    }
   return retorno;
}*/

/*Funcao verificar pilha vazia
** Param: ponteiro para pilha
*
bool empty(Pilha *p){
    if(p->topo == 0){ //Pilha Vazia
        return true;
    }else{
        return false;
    }
}*/

/*Funcao para andar x cm
** Param: distancia
*/
void anda_x_cm (float x){
float angulo;

	angulo = (x*20.835);

	if (angulo >= 0){
		setMotorReversed(dir, false);
		setMotorReversed(esq, false);
	} else {
		setMotorReversed(esq, true);
		setMotorReversed(dir, true);
	}

	moveMotorTarget(dir, angulo, 20);
	moveMotorTarget(esq, angulo, 20);

	waitUntilMotorStop(dir);
	waitUntilMotorStop(esq);

	setMotorReversed(dir, false);
	setMotorReversed(esq, false);

}

/*Funcao inserir
** Param: ponteiro para pilha, direcao e cor
*/
bool push (Pilha *p, TLegoColors cor, int dir){
    if(p->topo == p->max){ //Pilha cheia
        displayBigTextLine(line6,"Erro: stack overflow\n");
        return false;
    }else{
        p->elems[p->topo].cor = cor;
        p->elems[p->topo++].dir = dir;
        return true;
    }
}

/*Funcao troca sentido
** Param: ponteiro para pilha

void troca(Pilha *p){
int i;

	for(i=0;i<p->topo;i++){
		if(p->elems[i].dir == FRENTE){
			p->elems[i].dir = TRAS;
		}else if(p->elems[i].dir == ANTIHORARIO){
			p->elems[i].dir = HORARIO;
		}else if(p->elems[i].dir == HORARIO){
			p->elems[i].dir = ANTIHORARIO;
		}
	}

}
*/
//Funcao imprime
// Param: ponteiro para pilha
void imprime_pilha(Pilha *p){
int i;
	displayBigTextLine(line1,"Imprimir Pilha:\n");
    for(i=0;i<p->topo;i++){
        displayBigTextLine(line1,"cor:%d",p->elems[i].cor);
        displayBigTextLine(line2,"dir:%d",p->elems[i].dir);
    }
}

/*Funcao andar reto
** Param: sentido
*/
void AndarReto (int sentido){
	setMotorSync(dir,esq,0,sentido*POTENCIA);
}

/*Funcao girar robo
** Param: angulo, sentido
*/
void GirarRobo(int degree, int sentido){
	//Direita Angulo Negativo - angulo diminou se for para direita
	//Esquerda Angulo Positivo = angulo aumenta se for para esquerda

	//SET GIRO
	AndarReto(DESLIGA);

	//Verificar Angulo
	if(degree == 90){
		degree = degree - 10;
		}else if(degree == 180){
		displayTextLine(1,"ANGULO 180");
		degree = degree - 5;
	}

	if(degree == 0 && sentido == FRENTE){
		AndarReto(FRENTE);
	}

	resetGyro(S3);
	delay(1500);

	repeatUntil(abs(getGyroDegrees(S3)) > degree){
		if(sentido == HORARIO){ //Gira para direita
			displayTextLine(3,"girando sentido horario");
			setMotorSpeed(esq, FRENTE*POTENCIA_GIRO);
			setMotorSpeed(dir, TRAS*POTENCIA_GIRO);
			//delay(2000);
			}else{
			displayTextLine(3,"girando sentido antihorario");
			setMotorSpeed(esq, TRAS*POTENCIA_GIRO);
			setMotorSpeed(dir, FRENTE*POTENCIA_GIRO);
			//delay(2000);
		}
	}

	//Stop the motors at the end of the turn
	setMotorSpeed(esq, DESLIGA);
	setMotorSpeed(dir, DESLIGA);
	delay(1500);
	resetGyro(S3);
	delay(1500);
}

/* Função para Retornar a Cor lida pelo Sensor
** Params: porta conectada do sensor de cor
*/
TLegoColors getColor(tSensors sensor){
	bool getColor = false;
	TLegoColors color;

	while(!getColor){
		color = getColorName(sensor);
		if(color != colorNone)
			getColor = true;
		else
			getColor = false;
	}

	return color;
}

bool ultrassonico(){
	int vet[11];
	int i;
	int j;
	int aux;
	int k = 10;

	//Lê 11 valores de distância em CM
	for (i=0; i<11; i++){
	        vet[i] = getUSDistance(ult);
	}

	//Bubble Sort
	for(i = 0; i < 11; i++){
		for(j = 0; j < k; j++){
			if(vet[j] > vet[j+1]){
			aux = vet[j];
			vet[j] = vet[j+1];
			vet[j+1]=aux;
			}
		}
		k--;
	}

    //Ver se o sensor achou o boneco e retorna true ou false
	if (vet[5] < DIST_BONECO){
        return true;
	}else{
	    return false;
	}
}

/*Funcao para verificar se cor esta na pilha
** Param: ponteiro para pilha, cor
*/
bool checa_cor(Pilha *p, TLegoColors cor){
    int i;
    for(i=0;i<TAM;i++){
        if(p->elems[i].cor == cor){
            displayBigTextLine(line1,"ndeu certo");
            return true;
        }
    }
    return false;
}

/*Funcao para verificar se dir esta na pilha
** Param: ponteiro para pilha, direcao, cor
*/
bool checa_dir(Pilha *p, int dir, TLegoColors cor){
int i;
    for(i=0;i<TAM;i++){
        if(p->elems[i].dir == dir){
            if(p->elems[i].cor == cor){
                displayBigTextLine(line1,"ndeu certo"); //Cor e direcao salvo
            return true;
            }else{
                return false;
            }
        }
    }
    return false;
}

/*Retorna na ultima interseccao
** Param:
*/
void volta(bool plaza){
    int andar = 1;
    while(andar){
        AndarReto(TRAS);
        if(getColor(S2) != colorWhite && ultrassonico() == false && plaza == false){ // Verifica se esta em uma interseccao - verificar cor
            andar = 0;
        }
    }
}

/*Funcao que verificar qual direcao seguir, caso errada, volta para ultiam interseccao
** Param: Ponteiro para pilha, direcao, cor
*/
bool testa_dir(Pilha *p, int direcao, TLegoColors cor, bool plaza){
int andar = 1;

    GirarRobo(90,direcao); //Vira o robo para direcao dada

    while(andar){
        AndarReto(FRENTE); // Andar reto
        if(ultrassonico() == true){ //procura boneco enquanto testa
            bonecos_total++;
                p->elems[p->topo].bonecos_bifurcacao++;
                p->elems[p->topo].bonecos_direita++;
        }

        if(cor != colorWhite && cor != colorBlack){ // Verifica se esta em outra interseccao
            AndarReto(DESLIGA);
            return true;
        }else if(cor == colorBlack){ // Verifica se esta em rua sem saida - chao preto
            AndarReto(DESLIGA);
            volta(plaza); // Funcao que faz o robÃ´ voltar atÃ© a ultima interseccao
            return false;
        }
    }
    return false;
}

/*Funcao para o estado interseccao
** Param: ponteiro para pilha, cor
*/
void run_rua(Pilha *p, TLegoColors cor, bool plaza){
int i;

    if(ultrassonico() == true){ //Verifica de tem boneco
        bonecos_total++; //contar todos os bonecos
        p->elems[p->topo].bonecos_bifurcacao++; //contar bonecos na bifurcacao
        p->elems[p->topo].bonecos_direita++; //contar numero de bonecos a direita em uma bifurcacao
    }

    if(cor != colorWhite && !checa_cor(p,cor)){ //se cor for diferente de branco e nao estiver na pilha...
        if(!checa_dir(p,ANTIHORARIO,cor) && testa_dir(p,ANTIHORARIO,cor,plaza)){ //verifica se a direcao esta na pilha - ESQUERDA
            push(p,cor,ANTIHORARIO); //testa
        }else if(!checa_dir(p,HORARIO,cor) &&  testa_dir(p,HORARIO,cor,plaza)){
                push(p,cor,FRENTE); //testa
        }else{
            testa_dir(p,HORARIO,cor,plaza);
            push(p,cor,HORARIO);
        }
    }else{
       for(i=0;i<=TAM;i++){ //
         if(cor == p->elems[i].cor){
           GirarRobo(90,p->elems[i].dir);
          }
        }
    }
}

task main(){

displayText(line1,"task main -- 1");

		 Pilha *p;
			int i;
			bool ult, plaza = false;
			TLegoColors cor;
			int estado = RETO;

			/* inicialização necessárias */
		   p->max = TAM;
		   p->topo = 0;
		    for(i=0;i<TAM;i++){
		        p->elems[i].cor = colorBrown; /*testar inicialziar*/
		        p->elems[i].dir = 0;
		  	}

		  while(true){
		  	ult = ultrassonico();
    		cor = getColor(S2);
    		if(cor != colorWhite){
						anda_x_cm (10);
						displayText(line1,"estado interseccao");
    				estado = INTERSECCAO;
    		}else estado = RETO;
			}

			switch(estado){
				case INTERSECCAO:
						run_rua(p,cor,plaza);
						imprime_pilha(p);
						break;
				case RETO:
	    			AndarReto(FRENTE);
	    			break;
			}

}
